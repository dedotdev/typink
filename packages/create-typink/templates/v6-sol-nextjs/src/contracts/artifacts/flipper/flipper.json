{"compiler":{"version":"rustc 1.88.0"},"language":"ink! 6.0.0-alpha.4","output":{"abi":[{"type":"constructor","inputs":[{"name":"init_value","type":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"flip","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"get","inputs":[],"outputs":[{"name":"","type":"bool"}],"stateMutability":"view"},{"type":"event","name":"Flipped","inputs":[{"name":"old_value","type":"bool","indexed":false},{"name":"new_value","type":"bool","indexed":false},{"name":"caller","type":"address","indexed":true}],"anonymous":false}],"devdoc":{"version":1,"kind":"dev","author":"[your_name] <[your_email]>","methods":{"flip()":{"details":" A message that can be called on instantiated contracts.\n This one flips the value of the stored `bool` from `true`\n to `false` and vice versa."},"get()":{"details":" Simply returns the current value of our `bool`."}},"events":{"Flipped(bool,bool,address)":{"details":" Event emitted when the flipper value is flipped","params":{"old_value":" The old value before flipping","caller":" The account that triggered the flip","new_value":" The new value after flipping"}}}},"userdoc":{"version":1,"kind":"user"}},"settings":{"ink":{"hash":"0xa9a0f6e576869018eff65ff3c3e8db9922ced4d6f76eaaffea49de292800f19e","image":null,"build_info":{"build_mode":"Release","cargo_contract_version":"6.0.0-alpha.4","rust_toolchain":"stable-aarch64-apple-darwin"}}},"sources":{"lib.rs":{"content":"#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod flipper {\n    /// Event emitted when the flipper value is flipped\n    #[ink(event)]\n    pub struct Flipped {\n        /// The old value before flipping\n        old_value: bool,\n        /// The new value after flipping\n        new_value: bool,\n        /// The account that triggered the flip\n        #[ink(topic)]\n        caller: Address,\n    }\n\n    /// Defines the storage of your contract.\n    /// Add new fields to the below struct in order\n    /// to add new static storage fields to your contract.\n    #[ink(storage)]\n    pub struct Flipper {\n        /// Stores a single `bool` value on the storage.\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// A message that can be called on instantiated contracts.\n        /// This one flips the value of the stored `bool` from `true`\n        /// to `false` and vice versa.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            let old_value = self.value;\n            let new_value = !old_value;\n            self.value = new_value;\n\n            self.env().emit_event(Flipped {\n                old_value,\n                new_value,\n                caller: self.env().caller(),\n            });\n        }\n\n        /// Simply returns the current value of our `bool`.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n\n    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`\n    /// module and test functions are marked with a `#[test]` attribute.\n    /// The below code is technically just normal Rust code.\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n\n        /// We test a simple use case of our contract.\n        #[ink::test]\n        fn it_works() {\n            let mut flipper = Flipper::new(false);\n            assert_eq!(flipper.get(), false);\n            flipper.flip();\n            assert_eq!(flipper.get(), true);\n        }\n\n        /// Test that the Flipped event is emitted correctly\n        #[ink::test]\n        fn flip_emits_event() {\n            let mut flipper = Flipper::new(false);\n\n            flipper.flip();\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 1);\n\n            let decoded_event = &emitted_events[0];\n            if let Ok(Flipped { old_value, new_value, caller }) =\n                <Flipped as ink::scale::Decode>::decode(&mut &decoded_event.data[..]) {\n                assert_eq!(old_value, false);\n                assert_eq!(new_value, true);\n                let expected_caller = ink::env::test::default_accounts::<ink::env::DefaultEnvironment>().alice;\n                assert_eq!(caller, expected_caller);\n            } else {\n                panic!(\"Failed to decode Flipped event\");\n            }\n        }\n    }\n\n\n    /// This is how you'd write end-to-end (E2E) or integration tests for ink! contracts.\n    ///\n    /// When running these you need to make sure that you:\n    /// - Compile the tests with the `e2e-tests` feature flag enabled (`--features e2e-tests`)\n    /// - Are running a Substrate node which contains `pallet-contracts` in the background\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n\n        /// A helper function used for calling contract messages.\n        use ink_e2e::ContractsBackend;\n\n        /// The End-to-End test `Result` type.\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        /// We test that we can read and write a value from the on-chain contract.\n        #[ink_e2e::test]\n        async fn it_works(mut client: ink_e2e::Client<C, E>) -> E2EResult<()> {\n            // Given\n            let mut constructor = FlipperRef::new(false);\n            let contract = client\n                .instantiate(\"flipper\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Flipper>();\n\n            let get = call_builder.get();\n            let get_result = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_result.return_value(), false));\n\n            // When\n            let flip = call_builder.flip();\n            let _flip_result = client\n                .call(&ink_e2e::bob(), &flip)\n                .submit()\n                .await\n                .expect(\"flip failed\");\n\n            // Then\n            let get = call_builder.get();\n            let get_result = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_result.return_value(), true));\n\n            Ok(())\n        }\n    }\n}\n","keccak256":"0x9e4510f05158d2e490a67699a3f21dfa879420727a1bbdeda598ada3633d1bad"},"Cargo.toml":{"content":"[package]\nname = \"flipper\"\nversion = \"0.1.0\"\nauthors = [\"[your_name] <[your_email]>\"]\nedition = \"2024\"\n\n[dependencies]\nink = { git = \"https://github.com/use-ink/ink\", tag = \"v6.0.0-alpha.4\", version = \"6.0.0-alpha.4\", default-features = false, features = [\"unstable-hostfn\"] }\n\n[dev-dependencies]\nink_e2e = { git = \"https://github.com/use-ink/ink\", tag = \"v6.0.0-alpha.4\", version = \"6.0.0-alpha.4\" }\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\n    \"ink/std\",\n]\nink-as-dependency = []\ne2e-tests = []\n\n[package.metadata.ink-lang]\nabi = \"sol\"\n\n[lints.rust.unexpected_cfgs]\nlevel = \"warn\"\ncheck-cfg = [\n    'cfg(ink_abi, values(\"ink\", \"sol\", \"all\"))'\n]\n","keccak256":"0xa6638411f2bdc5bdd3d63e37d9a3c18757d11a24412e21a38c8375191663692c"}},"version":1}